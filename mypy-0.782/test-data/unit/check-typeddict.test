-- Create Instance

[case testCanCreateTypedDictInstanceWithKeywordArguments]
from mypy_extensions import TypedDict
Point = TypedDict('Point', {'x': int, 'y': int})
p = Point(x=42, y=1337)
reveal_type(p)  # N: Revealed type is 'TypedDict('__main__.Point', {'x': builtins.int, 'y': builtins.int})'
# Use values() to check fallback value type.
reveal_type(p.values()) # N: Revealed type is 'typing.Iterable[builtins.object*]'
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]
[targets sys, __main__]

[case testCanCreateTypedDictInstanceWithDictCall]
from mypy_extensions import TypedDict
Point = TypedDict('Point', {'x': int, 'y': int})
p = Point(dict(x=42, y=1337))
reveal_type(p)  # N: Revealed type is 'TypedDict('__main__.Point', {'x': builtins.int, 'y': builtins.int})'
# Use values() to check fallback value type.
reveal_type(p.values()) # N: Revealed type is 'typing.Iterable[builtins.object*]'
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testCanCreateTypedDictInstanceWithDictLiteral]
from mypy_extensions import TypedDict
Point = TypedDict('Point', {'x': int, 'y': int})
p = Point({'x': 42, 'y': 1337})
reveal_type(p)  # N: Revealed type is 'TypedDict('__main__.Point', {'x': builtins.int, 'y': builtins.int})'
# Use values() to check fallback value type.
reveal_type(p.values()) # N: Revealed type is 'typing.Iterable[builtins.object*]'
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testCanCreateTypedDictInstanceWithNoArguments]
from typing import TypeVar, Union
from mypy_extensions import TypedDict
EmptyDict = TypedDict('EmptyDict', {})
p = EmptyDict()
reveal_type(p)  # N: Revealed type is 'TypedDict('__main__.EmptyDict', {})'
reveal_type(p.values()) # N: Revealed type is 'typing.Iterable[builtins.object*]'
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]


-- Create Instance (Errors)

[case testCannotCreateTypedDictInstanceWithUnknownArgumentPattern]
from mypy_extensions import TypedDict
Point = TypedDict('Point', {'x': int, 'y': int})
p = Point(42, 1337)  # E: Expected keyword arguments, {...}, or dict(...) in TypedDict constructor
[builtins fixtures/dict.pyi]

[case testCannotCreateTypedDictInstanceNonLiteralItemName]
from mypy_extensions import TypedDict
Point = TypedDict('Point', {'x': int, 'y': int})
x = 'x'
p = Point({x: 42, 'y': 1337})  # E: Expected TypedDict key to be string literal
[builtins fixtures/dict.pyi]

[case testCannotCreateTypedDictInstanceWithExtraItems]
from mypy_extensions import TypedDict
Point = TypedDict('Point', {'x': int, 'y': int})
p = Point(x=42, y=1337, z=666)  # E: Extra key 'z' for TypedDict "Point"
[builtins fixtures/dict.pyi]

[case testCannotCreateTypedDictInstanceWithMissingItems]
from mypy_extensions import TypedDict
Point = TypedDict('Point', {'x': int, 'y': int})
p = Point(x=42)  # E: Key 'y' missing for TypedDict "Point"
[builtins fixtures/dict.pyi]

[case testCannotCreateTypedDictInstanceWithIncompatibleItemType]
from mypy_extensions import TypedDict
Point = TypedDict('Point', {'x': int, 'y': int})
p = Point(x='meaning_of_life', y=1337)  # E: Incompatible types (expression has type "str", TypedDict item "x" has type "int")
[builtins fixtures/dict.pyi]


-- Define TypedDict (Class syntax)

[case testCanCreateTypedDictWithClass]
# flags: --python-version 3.6
from mypy_extensions import TypedDict

class Point(TypedDict):
    x: int
    y: int

p = Point(x=42, y=1337)
reveal_type(p)  # N: Revealed type is 'TypedDict('__main__.Point', {'x': builtins.int, 'y': builtins.int})'
[builtins fixtures/dict.pyi]

[case testCanCreateTypedDictWithSubclass]
# flags: --python-version 3.6
from mypy_extensions import TypedDict

class Point1D(TypedDict):
    x: int
class Point2D(Point1D):
    y: int
r: Point1D
p: Point2D
reveal_type(r)  # N: Revealed type is 'TypedDict('__main__.Point1D', {'x': builtins.int})'
reveal_type(p)  # N: Revealed type is 'TypedDict('__main__.Point2D', {'x': builtins.int, 'y': builtins.int})'
[builtins fixtures/dict.pyi]

[case testCanCreateTypedDictWithSubclass2]
# flags: --python-version 3.6
from mypy_extensions import TypedDict

class Point1D(TypedDict):
    x: int
class Point2D(TypedDict, Point1D): # We also allow to include TypedDict in bases, it is simply ignored at runtime
    y: int

p: Point2D
reveal_type(p)  # N: Revealed type is 'TypedDict('__main__.Point2D', {'x': builtins.int, 'y': builtins.int})'
[builtins fixtures/dict.pyi]

[case testCanCreateTypedDictClassEmpty]
# flags: --python-version 3.6
from mypy_extensions import TypedDict

class EmptyDict(TypedDict):
    pass

p = EmptyDict()
reveal_type(p)  # N: Revealed type is 'TypedDict('__main__.EmptyDict', {})'
[builtins fixtures/dict.pyi]


[case testCanCreateTypedDictWithClassOldVersion]
# flags: --python-version 3.5

# Test that we can use class-syntax to merge TypedDicts even in
# versions without type annotations

from mypy_extensions import TypedDict

MovieBase1 = TypedDict(
    'MovieBase1', {'name': str, 'year': int})
MovieBase2 = TypedDict(
    'MovieBase2', {'based_on': str}, total=False)

class Movie(MovieBase1, MovieBase2):
    pass

def foo(x):
    # type: (Movie) -> None
    pass

foo({})  # E: Keys ('name', 'year') missing for TypedDict "Movie"
foo({'name': 'lol', 'year': 2009, 'based_on': 0})  # E: Incompatible types (expression has type "int", TypedDict item "based_on" has type "str")

[builtins fixtures/dict.pyi]

-- Define TypedDict (Class syntax errors)

[case testCannotCreateTypedDictWithClassOtherBases]
# flags: --python-version 3.6
from mypy_extensions import TypedDict

class A: pass

class Point1D(TypedDict, A): # E: All bases of a new TypedDict must be TypedDict types
    x: int
class Point2D(Point1D, A): # E: All bases of a new TypedDict must be TypedDict types
    y: int

p: Point2D
reveal_type(p)  # N: Revealed type is 'TypedDict('__main__.Point2D', {'x': builtins.int, 'y': builtins.int})'
[builtins fixtures/dict.pyi]

[case testCannotCreateTypedDictWithClassWithOtherStuff]
# flags: --python-version 3.6
from mypy_extensions import TypedDict

class Point(TypedDict):
    x: int
    y: int = 1 # E: Right hand side values are not supported in TypedDict
    def f(): pass # E: Invalid statement in TypedDict definition; expected "field_name: field_type"
    z = int # E: Invalid statement in TypedDict definition; expected "field_name: field_type"

p = Point(x=42, y=1337, z='whatever')
reveal_type(p)  # N: Revealed type is 'TypedDict('__main__.Point', {'x': builtins.int, 'y': builtins.int, 'z': Any})'
[builtins fixtures/dict.pyi]

[case testCanCreateTypedDictTypeWithUnderscoreItemName]
from mypy_extensions import TypedDict
Point = TypedDict('Point', {'x': int, 'y': int, '_fallback': object})
[builtins fixtures/dict.pyi]

[case testCanCreateTypedDictWithClassUnderscores]
# flags: --python-version 3.6
from mypy_extensions import TypedDict

class Point(TypedDict):
    x: int
    _y: int

p: Point
reveal_type(p) # N: Revealed type is 'TypedDict('__main__.Point', {'x': builtins.int, '_y': builtins.int})'
[builtins fixtures/dict.pyi]

[case testCannotCreateTypedDictWithDuplicateKey1]
# flags: --python-version 3.6
from mypy_extensions import TypedDict

class Bad(TypedDict):
    x: int
    x: str # E: Duplicate TypedDict key "x"

b: Bad
reveal_type(b) # N: Revealed type is 'TypedDict('__main__.Bad', {'x': builtins.int})'
[builtins fixtures/dict.pyi]

[case testCannotCreateTypedDictWithDuplicateKey2]
from typing import TypedDict

D1 = TypedDict("D1", {
    "x": int,
    "x": int,  # E: Duplicate TypedDict key "x"
})
D2 = TypedDict("D2", {"x": int, "x": str})  # E: Duplicate TypedDict key "x"

d1: D1
d2: D2
reveal_type(d1) # N: Revealed type is 'TypedDict('__main__.D1', {'x': builtins.int})'
reveal_type(d2) # N: Revealed type is 'TypedDict('__main__.D2', {'x': builtins.str})'
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testCanCreateTypedDictWithClassOverwriting]
# flags: --python-version 3.6
from mypy_extensions import TypedDict

class Point1(TypedDict):
    x: int
class Point2(TypedDict):
    x: float
class Bad(Point1, Point2): # E: Overwriting TypedDict field "x" while merging
    pass

b: Bad
reveal_type(b) # N: Revealed type is 'TypedDict('__main__.Bad', {'x': builtins.int})'
[builtins fixtures/dict.pyi]

[case testCanCreateTypedDictWithClassOverwriting2]
# flags: --python-version 3.6
from mypy_extensions import TypedDict

class Point1(TypedDict):
    x: int
class Point2(Point1):
    x: float # E: Overwriting TypedDict field "x" while extending

p2: Point2
reveal_type(p2) # N: Revealed type is 'TypedDict('__main__.Point2', {'x': builtins.float})'
[builtins fixtures/dict.pyi]


-- Subtyping

[case testCanConvertTypedDictToItself]
from mypy_extensions import TypedDict
Point = TypedDict('Point', {'x': int, 'y': int})
def identity(p: Point) -> Point:
    return p
[builtins fixtures/dict.pyi]

[case testCanConvertTypedDictToEquivalentTypedDict]
from mypy_extensions import TypedDict
PointA = TypedDict('PointA', {'x': int, 'y': int})
PointB = TypedDict('PointB', {'x': int, 'y': int})
def identity(p: PointA) -> PointB:
    return p
[builtins fixtures/dict.pyi]

[case testCannotConvertTypedDictToSimilarTypedDictWithNarrowerItemTypes]
from mypy_extensions import TypedDict
Point = TypedDict('Point', {'x': int, 'y': int})
ObjectPoint = TypedDict('ObjectPoint', {'x': object, 'y': object})
def convert(op: ObjectPoint) -> Point:
    return op  # E: Incompatible return value type (got "ObjectPoint", expected "Point")
[builtins fixtures/dict.pyi]

[case testCannotConvertTypedDictToSimilarTypedDictWithWiderItemTypes]
from mypy_extensions import TypedDict
Point = TypedDict('Point', {'x': int, 'y': int})
ObjectPoint = TypedDict('ObjectPoint', {'x': object, 'y': object})
def convert(p: Point) -> ObjectPoint:
    return p  # E: Incompatible return value type (got "Point", expected "ObjectPoint")
[builtins fixtures/dict.pyi]

[case testCannotConvertTypedDictToSimilarTypedDictWithIncompatibleItemTypes]
from mypy_extensions import TypedDict
Point = TypedDict('Point', {'x': int, 'y': int})
Chameleon = TypedDict('Chameleon', {'x': str, 'y': str})
def convert(p: Point) -> Chameleon:
    return p  # E: Incompatible return value type (got "Point", expected "Chameleon")
[builtins fixtures/dict.pyi]

[case testCanConvertTypedDictToNarrowerTypedDict]
from mypy_extensions import TypedDict
Point = TypedDict('Point', {'x': int, 'y': int})
Point1D = TypedDict('Point1D', {'x': int})
def narrow(p: Point) -> Point1D:
    return p
[builtins fixtures/dict.pyi]

[case testCannotConvertTypedDictToWiderTypedDict]
from mypy_extensions import TypedDict
Point = TypedDict('Point', {'x': int, 'y': int})
Point3D = TypedDict('Point3D', {'x': int, 'y': int, 'z': int})
def widen(p: Point) -> Point3D:
    return p  # E: Incompatible return value type (got "Point", expected "Point3D")
[builtins fixtures/dict.pyi]

[case testCanConvertTypedDictToCompatibleMapping]
from mypy_extensions import TypedDict
from typing import Mapping
Point = TypedDict('Point', {'x': int, 'y': int})
def as_mapping(p: Point) -> Mapping[str, object]:
    return p
[builtins fixtures/dict.pyi]

[case testCannotConvertTypedDictToIncompatibleMapping]
from mypy_extensions import TypedDict
from typing import Mapping
Point = TypedDict('Point', {'x': int, 'y': int})
def as_mapping(p: Point) -> Mapping[str, int]:
    return p  # E: Incompatible return value type (got "Point", expected "Mapping[str, int]")
[builtins fixtures/dict.pyi]

[case testTypedDictAcceptsIntForFloatDuckTypes]
from mypy_extensions import TypedDict
from typing import Any, Mapping
Point = TypedDict('Point', {'x': float, 'y': float})
def create_point() -> Point:
    return Point(x=1, y=2)
reveal_type(Point(x=1, y=2))  # N: Revealed type is 'TypedDict('__main__.Point', {'x': builtins.float, 'y': builtins.float})'
[builtins fixtures/dict.pyi]

[case testTypedDictDoesNotAcceptsFloatForInt]
from mypy_extensions import TypedDict
from typing import Any, Mapping
Point = TypedDict('Point', {'x': int, 'y': int})
def create_point() -> Point:
    return Point(x=1.2, y=2.5)
[out]
main:5: error: Incompatible types (expression has type "float", TypedDict item "x" has type "int")
main:5: error: Incompatible types (expression has type "float", TypedDict item "y" has type "int")
[builtins fixtures/dict.pyi]

[case testTypedDictAcceptsAnyType]
from mypy_extensions import TypedDict
from typing import Any, Mapping
Point = TypedDict('Point', {'x': float, 'y': float})
def create_point(something: Any) -> Point:
    return Point({
      'x': something.x,
      'y': something.y
    })
[builtins fixtures/dict.pyi]

[case testTypedDictValueTypeContext]
from mypy_extensions import TypedDict
from typing import List
D = TypedDict('D', {'x': List[int]})
reveal_type(D(x=[]))  # N: Revealed type is 'TypedDict('__main__.D', {'x': builtins.list[builtins.int]})'
[builtins fixtures/dict.pyi]

[case testCannotConvertTypedDictToDictOrMutableMapping]
from mypy_extensions import TypedDict
from typing import Dict, MutableMapping
Point = TypedDict('Point', {'x': int, 'y': int})
def as_dict(p: Point) -> Dict[str, int]:
    return p  # E: Incompatible return value type (got "Point", expected "Dict[str, int]")
def as_mutable_mapping(p: Point) -> MutableMapping[str, object]:
    return p  # E: Incompatible return value type (got "Point", expected "MutableMapping[str, object]")
[builtins fixtures/dict.pyi]
[typing fixtures/typing-full.pyi]

[case testCanConvertTypedDictToAny]
from mypy_extensions import TypedDict
from typing import Any
Point = TypedDict('Point', {'x': int, 'y': int})
def unprotect(p: Point) -> Any:
    return p
[builtins fixtures/dict.pyi]

[case testAnonymousTypedDictInErrorMessages]
from mypy_extensions import TypedDict

A = TypedDict('A', {'x': int, 'y': str})
B = TypedDict('B', {'x': int, 'z': str, 'a': int})
C = TypedDict('C', {'x': int, 'z': str, 'a': str})
a: A
b: B
c: C

def f(a: A) -> None: pass

l = [a, b]  # Join generates an anonymous TypedDict
f(l) # E: Argument 1 to "f" has incompatible type "List[TypedDict({'x': int})]"; expected "A"
ll = [b, c]
f(ll) # E: Argument 1 to "f" has incompatible type "List[TypedDict({'x': int, 'z': str})]"; expected "A"
[builtins fixtures/dict.pyi]

[case testTypedDictWithSimpleProtocol]
from typing_extensions import Protocol, TypedDict

class StrObjectMap(Protocol):
    def __getitem__(self, key: str) -> object: ...
class StrIntMap(Protocol):
    def __getitem__(self, key: str) -> int: ...

A = TypedDict('A', {'x': int, 'y': int})
B = TypedDict('B', {'x': int, 'y': str})

def fun(arg: StrObjectMap) -> None: ...
def fun2(arg: StrIntMap) -> None: ...
a: A
b: B
fun(a)
fun(b)
fun2(a) # Error
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]
[out]
main:17: error: Argument 1 to "fun2" has incompatible type "A"; expected "StrIntMap"
main:17: note: Following member(s) of "A" have conflicts:
main:17: note:     Expected:
main:17: note:         def __getitem__(self, str) -> int
main:17: note:     Got:
main:17: note:         def __getitem__(self, str) -> object

[case testTypedDictWithSimpleProtocolInference]
from typing_extensions import Protocol, TypedDict
from typing import TypeVar

T_co = TypeVar('T_co', covariant=True)
T = TypeVar('T')

class StrMap(Protocol[T_co]):
    def __getitem__(self, key: str) -> T_co: ...

A = TypedDict('A', {'x': int, 'y': int})
B = TypedDict('B', {'x': int, 'y': str})

def fun(arg: StrMap[T]) -> T:
    return arg['whatever']
a: A
b: B
reveal_type(fun(a))  # N: Revealed type is 'builtins.object*'
reveal_type(fun(b))  # N: Revealed type is 'builtins.object*'
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

-- Join

[case testJoinOfTypedDictHasOnlyCommonKeysAndNewFallback]
from mypy_extensions import TypedDict
TaggedPoint = TypedDict('TaggedPoint', {'type': str, 'x': int, 'y': int})
Point3D = TypedDict('Point3D', {'x': int, 'y': int, 'z': int})
p1 = TaggedPoint(type='2d', x=0, y=0)
p2 = Point3D(x=1, y=1, z=1)
joined_points = [p1, p2][0]
reveal_type(p1.values())   # N: Revealed type is 'typing.Iterable[builtins.object*]'
reveal_type(p2.values())   # N: Revealed type is 'typing.Iterable[builtins.object*]'
reveal_type(joined_points)  # N: Revealed type is 'TypedDict({'x': builtins.int, 'y': builtins.int})'
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testJoinOfTypedDictRemovesNonequivalentKeys]
from mypy_extensions import TypedDict
CellWithInt = TypedDict('CellWithInt', {'value': object, 'meta': int})
CellWithObject = TypedDict('CellWithObject', {'value': object, 'meta': object})
c1 = CellWithInt(value=1, meta=42)
c2 = CellWithObject(value=2, meta='turtle doves')
joined_cells = [c1, c2]
reveal_type(c1)             # N: Revealed type is 'TypedDict('__main__.CellWithInt', {'value': builtins.object, 'meta': builtins.int})'
reveal_type(c2)             # N: Revealed type is 'TypedDict('__main__.CellWithObject', {'value': builtins.object, 'meta': builtins.object})'
reveal_type(joined_cells)   # N: Revealed type is 'builtins.list[TypedDict({'value': builtins.object})]'
[builtins fixtures/dict.pyi]

[case testJoinOfDisjointTypedDictsIsEmptyTypedDict]
from mypy_extensions import TypedDict
Point = TypedDict('Point', {'x': int, 'y': int})
Cell = TypedDict('Cell', {'value': object})
d1 = Point(x=0, y=0)
d2 = Cell(value='pear tree')
joined_dicts = [d1, d2]
reveal_type(d1)             # N: Revealed type is 'TypedDict('__main__.Point', {'x': builtins.int, 'y': builtins.int})'
reveal_type(d2)             # N: Revealed type is 'TypedDict('__main__.Cell', {'value': builtins.object})'
reveal_type(joined_dicts)   # N: Revealed type is 'builtins.list[TypedDict({})]'
[builtins fixtures/dict.pyi]

[case testJoinOfTypedDictWithCompatibleMappingIsMapping]
from mypy_extensions import TypedDict
from typing import Mapping
Cell = TypedDict('Cell', {'value': int})
left = Cell(value=42)
right = {'score': 999}  # type: Mapping[str, int]
joined1 = [left, right]
joined2 = [right, left]
reveal_type(joined1)  # N: Revealed type is 'builtins.list[typing.Mapping*[builtins.str, builtins.object]]'
reveal_type(joined2)  # N: Revealed type is 'builtins.list[typing.Mapping*[builtins.str, builtins.object]]'
[builtins fixtures/dict.pyi]

[case testJoinOfTypedDictWithCompatibleMappingSupertypeIsSupertype]
from mypy_extensions import TypedDict
from typing import Sized
Cell = TypedDict('Cell', {'value': int})
left = Cell(value=42)
right = {'score': 999}  # type: Sized
joined1 = [left, right]
joined2 = [right, left]
reveal_type(joined1)  # N: Revealed type is 'builtins.list[typing.Sized*]'
reveal_type(joined2)  # N: Revealed type is 'builtins.list[typing.Sized*]'
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testJoinOfTypedDictWithIncompatibleTypeIsObject]
from mypy_extensions import TypedDict
from typing import Mapping
Cell = TypedDict('Cell', {'value': int})
left = Cell(value=42)
right = 42
joined1 = [left, right]
joined2 = [right, left]
reveal_type(joined1)  # N: Revealed type is 'builtins.list[builtins.object*]'
reveal_type(joined2)  # N: Revealed type is 'builtins.list[builtins.object*]'
[builtins fixtures/dict.pyi]


-- Meet

[case testMeetOfTypedDictsWithCompatibleCommonKeysHasAllKeysAndNewFallback]
from mypy_extensions import TypedDict
from typing import TypeVar, Callable
XY = TypedDict('XY', {'x': int, 'y': int})
YZ = TypedDict('YZ', {'y': int, 'z': int})
T = TypeVar('T')
def f(x: Callable[[T, T], None]) -> T: pass
def g(x: XY, y: YZ) -> None: pass
reveal_type(f(g))  # N: Revealed type is 'TypedDict({'x': builtins.int, 'y': builtins.int, 'z': builtins.int})'
[builtins fixtures/dict.pyi]

[case testMeetOfTypedDictsWithIncompatibleCommonKeysIsUninhabited]
# flags: --strict-optional
from mypy_extensions import TypedDict
from typing import TypeVar, Callable
XYa = TypedDict('XYa', {'x': int, 'y': int})
YbZ = TypedDict('YbZ', {'y': object, 'z': int})
T = TypeVar('T')
def f(x: Callable[[T, T], None]) -> T: pass
def g(x: XYa, y: YbZ) -> None: pass
reveal_type(f(g))  # N: Revealed type is '<nothing>'
[builtins fixtures/dict.pyi]

[case testMeetOfTypedDictsWithNoCommonKeysHasAllKeysAndNewFallback]
from mypy_extensions import TypedDict
from typing import TypeVar, Callable
X = TypedDict('X', {'x': int})
Z = TypedDict('Z', {'z': int})
T = TypeVar('T')
def f(x: Callable[[T, T], None]) -> T: pass
def g(x: X, y: Z) -> None: pass
reveal_type(f(g))  # N: Revealed type is 'TypedDict({'x': builtins.int, 'z': builtins.int})'
[builtins fixtures/dict.pyi]

# TODO: It would be more accurate for the meet to be TypedDict instead.
[case testMeetOfTypedDictWithCompatibleMappingIsUninhabitedForNow]
# flags: --strict-optional
from mypy_extensions import TypedDict
from typing import TypeVar, Callable, Mapping
X = TypedDict('X', {'x': int})
M = Mapping[str, int]
T = TypeVar('T')
def f(x: Callable[[T, T], None]) -> T: pass
def g(x: X, y: M) -> None: pass
reveal_type(f(g))  # N: Revealed type is '<nothing>'
[builtins fixtures/dict.pyi]

[case testMeetOfTypedDictWithIncompatibleMappingIsUninhabited]
# flags: --strict-optional
from mypy_extensions import TypedDict
from typing import TypeVar, Callable, Mapping
X = TypedDict('X', {'x': int})
M = Mapping[str, str]
T = TypeVar('T')
def f(x: Callable[[T, T], None]) -> T: pass
def g(x: X, y: M) -> None: pass
reveal_type(f(g))  # N: Revealed type is '<nothing>'
[builtins fixtures/dict.pyi]

[case testMeetOfTypedDictWithCompatibleMappingSuperclassIsUninhabitedForNow]
# flags: --strict-optional
from mypy_extensions import TypedDict
from typing import TypeVar, Callable, Iterable
X = TypedDict('X', {'x': int})
I = Iterable[str]
T = TypeVar('T')
def f(x: Callable[[T, T], None]) -> T: pass
def g(x: X, y: I) -> None: pass
reveal_type(f(g))  # N: Revealed type is 'TypedDict('__main__.X', {'x': builtins.int})'
[builtins fixtures/dict.pyi]

[case testMeetOfTypedDictsWithNonTotal]
from mypy_extensions import TypedDict
from typing import TypeVar, Callable
XY = TypedDict('XY', {'x': int, 'y': int}, total=False)
YZ = TypedDict('YZ', {'y': int, 'z': int}, total=False)
T = TypeVar('T')
def f(x: Callable[[T, T], None]) -> T: pass
def g(x: XY, y: YZ) -> None: pass
reveal_type(f(g))  # N: Revealed type is 'TypedDict({'x'?: builtins.int, 'y'?: builtins.int, 'z'?: builtins.int})'
[builtins fixtures/dict.pyi]

[case testMeetOfTypedDictsWithNonTotalAndTotal]
from mypy_extensions import TypedDict
from typing import TypeVar, Callable
XY = TypedDict('XY', {'x': int}, total=False)
YZ = TypedDict('YZ', {'y': int, 'z': int})
T = TypeVar('T')
def f(x: Callable[[T, T], None]) -> T: pass
def g(x: XY, y: YZ) -> None: pass
reveal_type(f(g))  # N: Revealed type is 'TypedDict({'x'?: builtins.int, 'y': builtins.int, 'z': builtins.int})'
[builtins fixtures/dict.pyi]

[case testMeetOfTypedDictsWithIncompatibleNonTotalAndTotal]
# flags: --strict-optional
from mypy_extensions import TypedDict
from typing import TypeVar, Callable
XY = TypedDict('XY', {'x': int, 'y': int}, total=False)
YZ = TypedDict('YZ', {'y': int, 'z': int})
T = TypeVar('T')
def f(x: Callable[[T, T], None]) -> T: pass
def g(x: XY, y: YZ) -> None: pass
reveal_type(f(g)) # N: Revealed type is '<nothing>'
[builtins fixtures/dict.pyi]


-- Constraint Solver

[case testTypedDictConstraintsAgainstIterable]
from typing import TypeVar, Iterable
from mypy_extensions import TypedDict
T = TypeVar('T')
def f(x: Iterable[T]) -> T: pass
A = TypedDict('A', {'x': int})
a: A
reveal_type(f(a)) # N: Revealed type is 'builtins.str*'
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

-- TODO: Figure out some way to trigger the ConstraintBuilderVisitor.visit_typeddict_type() path.


-- Special Method: __getitem__

[case testCanGetItemOfTypedDictWithValidStringLiteralKey]
from mypy_extensions import TypedDict
TaggedPoint = TypedDict('TaggedPoint', {'type': str, 'x': int, 'y': int})
p = TaggedPoint(type='2d', x=42, y=1337)
reveal_type(p['type'])  # N: Revealed type is 'builtins.str'
reveal_type(p['x'])     # N: Revealed type is 'builtins.int'
reveal_type(p['y'])     # N: Revealed type is 'builtins.int'
[builtins fixtures/dict.pyi]

[case testCanGetItemOfTypedDictWithValidBytesOrUnicodeLiteralKey]
# flags: --python-version 2.7
from mypy_extensions import TypedDict
Cell = TypedDict('Cell', {'value': int})
c = Cell(value=42)
reveal_type(c['value'])   # N: Revealed type is 'builtins.int'
reveal_type(c[u'value'])  # N: Revealed type is 'builtins.int'
[builtins_py2 fixtures/dict.pyi]

[case testCannotGetItemOfTypedDictWithInvalidStringLiteralKey]
from mypy_extensions import TypedDict
TaggedPoint = TypedDict('TaggedPoint', {'type': str, 'x': int, 'y': int})
p: TaggedPoint
p['typ']  # E: TypedDict "TaggedPoint" has no key 'typ' \
          # N: Did you mean "type"?
[builtins fixtures/dict.pyi]

[case testTypedDictWithUnicodeName]
# flags: --python-version 2.7
from mypy_extensions import TypedDict
TaggedPoint = TypedDict(u'TaggedPoint', {'type': str, 'x': int, 'y': int})
[builtins fixtures/dict.pyi]

[case testCannotGetItemOfAnonymousTypedDictWithInvalidStringLiteralKey]
from typing import TypeVar
from mypy_extensions import TypedDict
A = TypedDict('A', {'x': str, 'y': int, 'z': str})
B = TypedDict('B', {'x': str, 'z': int})
C = TypedDict('C', {'x': str, 'y': int, 'z': int})
T = TypeVar('T')
def join(x: T, y: T) -> T: return x
ab = join(A(x='', y=1, z=''), B(x='', z=1))
ac = join(A(x='', y=1, z=''), C(x='', y=0, z=1))
ab['y']  # E: 'y' is not a valid TypedDict key; expected one of ('x')
ac['a']  # E: 'a' is not a valid TypedDict key; expected one of ('x', 'y')
[builtins fixtures/dict.pyi]

[case testCannotGetItemOfTypedDictWithNonLiteralKey]
from mypy_extensions import TypedDict
from typing import Union
TaggedPoint = TypedDict('TaggedPoint', {'type': str, 'x': int, 'y': int})
p = TaggedPoint(type='2d', x=42, y=1337)
def get_coordinate(p: TaggedPoint, key: str) -> Union[str, int]:
    return p[key]  # E: TypedDict key must be a string literal; expected one of ('type', 'x', 'y')
[builtins fixtures/dict.pyi]


-- Special Method: __setitem__

[case testCanSetItemOfTypedDictWithValidStringLiteralKeyAndCompatibleValueType]
from mypy_extensions import TypedDict
TaggedPoint = TypedDict('TaggedPoint', {'type': str, 'x': int, 'y': int})
p = TaggedPoint(type='2d', x=42, y=1337)
p['type'] = 'two_d'
p['x'] = 1
[builtins fixtures/dict.pyi]

[case testCannotSetItemOfTypedDictWithIncompatibleValueType]
from mypy_extensions import TypedDict
TaggedPoint = TypedDict('TaggedPoint', {'type': str, 'x': int, 'y': int})
p = TaggedPoint(type='2d', x=42, y=1337)
p['x'] = 'y'  # E: Argument 2 has incompatible type "str"; expected "int"
[builtins fixtures/dict.pyi]

[case testCannotSetItemOfTypedDictWithInvalidStringLiteralKey]
from mypy_extensions import TypedDict
TaggedPoint = TypedDict('TaggedPoint', {'type': str, 'x': int, 'y': int})
p = TaggedPoint(type='2d', x=42, y=1337)
p['z'] = 1  # E: TypedDict "TaggedPoint" has no key 'z'
[builtins fixtures/dict.pyi]

[case testCannotSetItemOfTypedDictWithNonLiteralKey]
from mypy_extensions import TypedDict
from typing import Union
TaggedPoint = TypedDict('TaggedPoint', {'type': str, 'x': int, 'y': int})
p = TaggedPoint(type='2d', x=42, y=1337)
def set_coordinate(p: TaggedPoint, key: str, value: int) -> None:
    p[key] = value  # E: TypedDict key must be a string literal; expected one of ('type', 'x', 'y')
[builtins fixtures/dict.pyi]


-- isinstance

[case testTypedDictWithIsInstanceAndIsSubclass]
from mypy_extensions import TypedDict
D = TypedDict('D', {'x': int})
d: object
if isinstance(d, D):   # E: Cannot use isinstance() with TypedDict type
    reveal_type(d)     # N: Revealed type is '__main__.D'
issubclass(object, D)  # E: Cannot use issubclass() with TypedDict type
[builtins fixtures/isinstancelist.pyi]


-- Scoping

[case testTypedDictInClassNamespace]
# https://github.com/python/mypy/pull/2553#issuecomment-266474341
from mypy_extensions import TypedDict
class C:
    def f(self):
        A = TypedDict('A', {'x': int})
    def g(self):
        A = TypedDict('A', {'y': int})
C.A  # E: "Type[C]" has no attribute "A"
[builtins fixtures/dict.pyi]

[case testTypedDictInFunction]
from mypy_extensions import TypedDict
def f() -> None:
    A = TypedDict('A', {'x': int})
A  # E: Name 'A' is not defined
[builtins fixtures/dict.pyi]


-- Union simplification / proper subtype checks

[case testTypedDictUnionSimplification]
from typing import TypeVar, Union, Any, cast
from mypy_extensions import TypedDict

T = TypeVar('T')
S = TypeVar('S')
def u(x: T, y: S) -> Union[S, T]: pass

C = TypedDict('C', {'a': int})
D = TypedDict('D', {'a': int, 'b': int})
E = TypedDict('E', {'a': str})
F = TypedDict('F', {'x': int})
G = TypedDict('G', {'a': Any})

c = C(a=1)
d = D(a=1, b=1)
e = E(a='')
f = F(x=1)
g = G(a=cast(Any, 1))  # Work around #2610

reveal_type(u(d, d)) # N: Revealed type is 'TypedDict('__main__.D', {'a': builtins.int, 'b': builtins.int})'
reveal_type(u(c, d)) # N: Revealed type is 'TypedDict('__main__.C', {'a': builtins.int})'
reveal_type(u(d, c)) # N: Revealed type is 'TypedDict('__main__.C', {'a': builtins.int})'
reveal_type(u(c, e)) # N: Revealed type is 'Union[TypedDict('__main__.E', {'a': builtins.str}), TypedDict('__main__.C', {'a': builtins.int})]'
reveal_type(u(e, c)) # N: Revealed type is 'Union[TypedDict('__main__.C', {'a': builtins.int}), TypedDict('__main__.E', {'a': builtins.str})]'
reveal_type(u(c, f)) # N: Revealed type is 'Union[TypedDict('__main__.F', {'x': builtins.int}), TypedDict('__main__.C', {'a': builtins.int})]'
reveal_type(u(f, c)) # N: Revealed type is 'Union[TypedDict('__main__.C', {'a': builtins.int}), TypedDict('__main__.F', {'x': builtins.int})]'
reveal_type(u(c, g)) # N: Revealed type is 'Union[TypedDict('__main__.G', {'a': Any}), TypedDict('__main__.C', {'a': builtins.int})]'
reveal_type(u(g, c)) # N: Revealed type is 'Union[TypedDict('__main__.C', {'a': builtins.int}), TypedDict('__main__.G', {'a': Any})]'
[builtins fixtures/dict.pyi]

[case testTypedDictUnionSimplification2]
from typing import TypeVar, Union, Mapping, Any
from mypy_extensions import TypedDict

T = TypeVar('T')
S = TypeVar('S')
def u(x: T, y: S) -> Union[S, T]: pass

C = TypedDict('C', {'a': int, 'b': int})

c = C(a=1, b=1)
m_s_o: Mapping[str, object]
m_s_s: Mapping[str, str]
m_i_i: Mapping[int, int]
m_s_a: Mapping[str, Any]

reveal_type(u(c, m_s_o)) # N: Revealed type is 'typing.Mapping*[builtins.str, builtins.object]'
reveal_type(u(m_s_o, c)) # N: Revealed type is 'typing.Mapping*[builtins.str, builtins.object]'
reveal_type(u(c, m_s_s)) # N: Revealed type is 'Union[typing.Mapping*[builtins.str, builtins.str], TypedDict('__main__.C', {'a': builtins.int, 'b': builtins.int})]'
reveal_type(u(c, m_i_i)) # N: Revealed type is 'Union[typing.Mapping*[builtins.int, builtins.int], TypedDict('__main__.C', {'a': builtins.int, 'b': builtins.int})]'
reveal_type(u(c, m_s_a)) # N: Revealed type is 'Union[typing.Mapping*[builtins.str, Any], TypedDict('__main__.C', {'a': builtins.int, 'b': builtins.int})]'
[builtins fixtures/dict.pyi]

[case testTypedDictUnionUnambiguousCase]
from typing import Union, Mapping, Any, cast
from typing_extensions import TypedDict, Literal

A = TypedDict('A', {'@type': Literal['a-type'], 'a': str})
B = TypedDict('B', {'@type': Literal['b-type'], 'b': int})

c: Union[A, B] = {'@type': 'a-type', 'a': 'Test'}
reveal_type(c) # N: Revealed type is 'Union[TypedDict('__main__.A', {'@type': Literal['a-type'], 'a': builtins.str}), TypedDict('__main__.B', {'@type': Literal['b-type'], 'b': builtins.int})]'
[builtins fixtures/tuple.pyi]

[case testTypedDictUnionAmbiguousCase]
from typing import Union, Mapping, Any, cast
from typing_extensions import TypedDict, Literal

A = TypedDict('A', {'@type': Literal['a-type'], 'a': str})
B = TypedDict('B', {'@type': Literal['a-type'], 'a': str})

c: Union[A, B] = {'@type': 'a-type', 'a': 'Test'} # E: Type of TypedDict is ambiguous, could be any of ("A", "B") \
                                                  # E: Incompatible types in assignment (expression has type "Dict[str, str]", variable has type "Union[A, B]")
[builtins fixtures/dict.pyi]

-- Use dict literals

[case testTypedDictDictLiterals]
from mypy_extensions import TypedDict

Point = TypedDict('Point', {'x': int, 'y': int})

def f(p: Point) -> None:
    if int():
        p = {'x': 2, 'y': 3}
        p = {'x': 2}  # E: Key 'y' missing for TypedDict "Point"
        p = dict(x=2, y=3)

f({'x': 1, 'y': 3})
f({'x': 1, 'y': 'z'})  # E: Incompatible types (expression has type "str", TypedDict item "y" has type "int")

f(dict(x=1, y=3))
f(dict(x=1, y=3, z=4))  # E: Extra key 'z' for TypedDict "Point"
f(dict(x=1, y=3, z=4, a=5))  # E: Extra keys ('z', 'a') for TypedDict "Point"

[builtins fixtures/dict.pyi]

[case testTypedDictExplicitTypes]
from mypy_extensions import TypedDict

Point = TypedDict('Point', {'x': int, 'y': int})

p1a: Point = {'x': 'hi'}  # E: Key 'y' missing for TypedDict "Point"
p1b: Point = {}           # E: Keys ('x', 'y') missing for TypedDict "Point"

p2: Point
p2 = dict(x='bye')  # E: Key 'y' missing for TypedDict "Point"

p3 = Point(x=1, y=2)
if int():
    p3 = {'x': 'hi'}  # E: Key 'y' missing for TypedDict "Point"

p4: Point = {'x': 1, 'y': 2}

[builtins fixtures/dict.pyi]

[case testCannotCreateAnonymousTypedDictInstanceUsingDictLiteralWithExtraItems]
from mypy_extensions import TypedDict
from typing import TypeVar
A = TypedDict('A', {'x': int, 'y': int})
B = TypedDict('B', {'x': int, 'y': str})
T = TypeVar('T')
def join(x: T, y: T) -> T: return x
ab = join(A(x=1, y=1), B(x=1, y=''))
if int():
    ab = {'x': 1, 'z': 1} # E: Expected TypedDict key 'x' but found keys ('x', 'z')
[builtins fixtures/dict.pyi]

[case testCannotCreateAnonymousTypedDictInstanceUsingDictLiteralWithMissingItems]
from mypy_extensions import TypedDict
from typing import TypeVar
A = TypedDict('A', {'x': int, 'y': int, 'z': int})
B = TypedDict('B', {'x': int, 'y': int, 'z': str})
T = TypeVar('T')
def join(x: T, y: T) -> T: return x
ab = join(A(x=1, y=1, z=1), B(x=1, y=1, z=''))
if int():
    ab = {} # E: Expected TypedDict keys ('x', 'y') but found no keys
[builtins fixtures/dict.pyi]


-- Other TypedDict methods

[case testTypedDictGetMethod]
# flags: --strict-optional
from mypy_extensions import TypedDict
class A: pass
D = TypedDict('D', {'x': int, 'y': str})
d: D
reveal_type(d.get('x')) # N: Revealed type is 'Union[builtins.int, None]'
reveal_type(d.get('y')) # N: Revealed type is 'Union[builtins.str, None]'
reveal_type(d.get('x', A())) # N: Revealed type is 'Union[builtins.int, __main__.A]'
reveal_type(d.get('x', 1)) # N: Revealed type is 'builtins.int'
reveal_type(d.get('y', None)) # N: Revealed type is 'Union[builtins.str, None]'
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictGetMethodTypeContext]
# flags: --strict-optional
from typing import List
from mypy_extensions import TypedDict
class A: pass
D = TypedDict('D', {'x': List[int], 'y': int})
d: D
reveal_type(d.get('x', [])) # N: Revealed type is 'builtins.list[builtins.int]'
d.get('x', ['x']) # E: List item 0 has incompatible type "str"; expected "int"
a = ['']
reveal_type(d.get('x', a)) # N: Revealed type is 'Union[builtins.list[builtins.int], builtins.list[builtins.str*]]'
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictGetMethodInvalidArgs]
from mypy_extensions import TypedDict
D = TypedDict('D', {'x': int, 'y': str})
d: D
d.get() # E: All overload variants of "get" of "Mapping" require at least one argument \
        # N: Possible overload variants: \
        # N:     def get(self, k: str) -> object \
        # N:     def [V] get(self, k: str, default: object) -> object
d.get('x', 1, 2) # E: No overload variant of "get" of "Mapping" matches argument types "str", "int", "int" \
                 # N: Possible overload variants: \
                 # N:     def get(self, k: str) -> object \
                 # N:     def [V] get(self, k: str, default: Union[int, V]) -> object
x = d.get('z') # E: TypedDict "D" has no key 'z'
reveal_type(x) # N: Revealed type is 'Any'
s = ''
y = d.get(s)
reveal_type(y) # N: Revealed type is 'builtins.object*'
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictMissingMethod]
from mypy_extensions import TypedDict
D = TypedDict('D', {'x': int, 'y': str})
d: D
d.bad(1) # E: "D" has no attribute "bad"
[builtins fixtures/dict.pyi]

[case testTypedDictChainedGetMethodWithDictFallback]
from mypy_extensions import TypedDict
D = TypedDict('D', {'x': int, 'y': str})
E = TypedDict('E', {'d': D})
p = E(d=D(x=0, y=''))
reveal_type(p.get('d', {'x': 1, 'y': ''})) # N: Revealed type is 'TypedDict('__main__.D', {'x': builtins.int, 'y': builtins.str})'
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictGetDefaultParameterStillTypeChecked]
from mypy_extensions import TypedDict
TaggedPoint = TypedDict('TaggedPoint', {'type': str, 'x': int, 'y': int})
p = TaggedPoint(type='2d', x=42, y=1337)
p.get('x', 1 + 'y')     # E: Unsupported operand types for + ("int" and "str")
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictChainedGetWithEmptyDictDefault]
# flags: --strict-optional
from mypy_extensions import TypedDict
C = TypedDict('C', {'a': int})
D = TypedDict('D', {'x': C, 'y': str})
d: D
reveal_type(d.get('x', {})) \
    # N: Revealed type is 'TypedDict('__main__.C', {'a'?: builtins.int})'
reveal_type(d.get('x', None)) \
    # N: Revealed type is 'Union[TypedDict('__main__.C', {'a': builtins.int}), None]'
reveal_type(d.get('x', {}).get('a')) # N: Revealed type is 'Union[builtins.int, None]'
reveal_type(d.get('x', {})['a']) # N: Revealed type is 'builtins.int'
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]


-- Totality (the "total" keyword argument)

[case testTypedDictWithTotalTrue]
from mypy_extensions import TypedDict
D = TypedDict('D', {'x': int, 'y': str}, total=True)
d: D
reveal_type(d) \
    # N: Revealed type is 'TypedDict('__main__.D', {'x': builtins.int, 'y': builtins.str})'
[builtins fixtures/dict.pyi]

[case testTypedDictWithInvalidTotalArgument]
from mypy_extensions import TypedDict
A = TypedDict('A', {'x': int}, total=0) # E: TypedDict() "total" argument must be True or False
B = TypedDict('B', {'x': int}, total=bool) # E: TypedDict() "total" argument must be True or False
C = TypedDict('C', {'x': int}, x=False) # E: Unexpected keyword argument "x" for "TypedDict"
D = TypedDict('D', {'x': int}, False) # E: Unexpected arguments to TypedDict()
[builtins fixtures/dict.pyi]

[case testTypedDictWithTotalFalse]
from mypy_extensions import TypedDict
D = TypedDict('D', {'x': int, 'y': str}, total=False)
def f(d: D) -> None:
    reveal_type(d) # N: Revealed type is 'TypedDict('__main__.D', {'x'?: builtins.int, 'y'?: builtins.str})'
f({})
f({'x': 1})
f({'y': ''})
f({'x': 1, 'y': ''})
f({'x': 1, 'z': ''}) # E: Extra key 'z' for TypedDict "D"
f({'x': ''}) # E: Incompatible types (expression has type "str", TypedDict item "x" has type "int")
[builtins fixtures/dict.pyi]

[case testTypedDictConstructorWithTotalFalse]
from mypy_extensions import TypedDict
D = TypedDict('D', {'x': int, 'y': str}, total=False)
def f(d: D) -> None: pass
reveal_type(D()) # N: Revealed type is 'TypedDict('__main__.D', {'x'?: builtins.int, 'y'?: builtins.str})'
reveal_type(D(x=1)) # N: Revealed type is 'TypedDict('__main__.D', {'x'?: builtins.int, 'y'?: builtins.str})'
f(D(y=''))
f(D(x=1, y=''))
f(D(x=1, z='')) # E: Extra key 'z' for TypedDict "D"
f(D(x='')) # E: Incompatible types (expression has type "str", TypedDict item "x" has type "int")
[builtins fixtures/dict.pyi]

[case testTypedDictIndexingWithNonRequiredKey]
from mypy_extensions import TypedDict
D = TypedDict('D', {'x': int, 'y': str}, total=False)
d: D
reveal_type(d['x']) # N: Revealed type is 'builtins.int'
reveal_type(d['y']) # N: Revealed type is 'builtins.str'
reveal_type(d.get('x')) # N: Revealed type is 'builtins.int'
reveal_type(d.get('y')) # N: Revealed type is 'builtins.str'
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictSubtypingWithTotalFalse]
from mypy_extensions import TypedDict
A = TypedDict('A', {'x': int})
B = TypedDict('B', {'x': int}, total=False)
C = TypedDict('C', {'x': int, 'y': str}, total=False)
def fa(a: A) -> None: pass
def fb(b: B) -> None: pass
def fc(c: C) -> None: pass
a: A
b: B
c: C
fb(b)
fc(c)
fb(c)
fb(a) # E: Argument 1 to "fb" has incompatible type "A"; expected "B"
fa(b) # E: Argument 1 to "fa" has incompatible type "B"; expected "A"
fc(b) # E: Argument 1 to "fc" has incompatible type "B"; expected "C"
[builtins fixtures/dict.pyi]

[case testTypedDictJoinWithTotalFalse]
from typing import TypeVar
from mypy_extensions import TypedDict
A = TypedDict('A', {'x': int})
B = TypedDict('B', {'x': int}, total=False)
C = TypedDict('C', {'x': int, 'y': str}, total=False)
T = TypeVar('T')
def j(x: T, y: T) -> T: return x
a: A
b: B
c: C
reveal_type(j(a, b)) \
    # N: Revealed type is 'TypedDict({})'
reveal_type(j(b, b)) \
    # N: Revealed type is 'TypedDict({'x'?: builtins.int})'
reveal_type(j(c, c)) \
    # N: Revealed type is 'TypedDict({'x'?: builtins.int, 'y'?: builtins.str})'
reveal_type(j(b, c)) \
    # N: Revealed type is 'TypedDict({'x'?: builtins.int})'
reveal_type(j(c, b)) \
    # N: Revealed type is 'TypedDict({'x'?: builtins.int})'
[builtins fixtures/dict.pyi]

[case testTypedDictClassWithTotalArgument]
from mypy_extensions import TypedDict
class D(TypedDict, total=False):
    x: int
    y: str
d: D
reveal_type(d) # N: Revealed type is 'TypedDict('__main__.D', {'x'?: builtins.int, 'y'?: builtins.str})'
[builtins fixtures/dict.pyi]

[case testTypedDictClassWithInvalidTotalArgument]
from mypy_extensions import TypedDict
class D(TypedDict, total=1): # E: Value of "total" must be True or False
    x: int
class E(TypedDict, total=bool): # E: Value of "total" must be True or False
    x: int
class F(TypedDict, total=xyz): # E: Value of "total" must be True or False \
                               # E: Name 'xyz' is not defined
    x: int
[builtins fixtures/dict.pyi]

[case testTypedDictClassInheritanceWithTotalArgument]
from mypy_extensions import TypedDict
class A(TypedDict):
    x: int
class B(TypedDict, A, total=False):
    y: int
class C(TypedDict, B, total=True):
    z: str
c: C
reveal_type(c) # N: Revealed type is 'TypedDict('__main__.C', {'x': builtins.int, 'y'?: builtins.int, 'z': builtins.str})'
[builtins fixtures/dict.pyi]

[case testNonTotalTypedDictInErrorMessages]
from mypy_extensions import TypedDict

A = TypedDict('A', {'x': int, 'y': str}, total=False)
B = TypedDict('B', {'x': int, 'z': str, 'a': int}, total=False)
C = TypedDict('C', {'x': int, 'z': str, 'a': str}, total=False)
a: A
b: B
c: C

def f(a: A) -> None: pass

l = [a, b]  # Join generates an anonymous TypedDict
f(l) # E: Argument 1 to "f" has incompatible type "List[TypedDict({'x'?: int})]"; expected "A"
ll = [b, c]
f(ll) # E: Argument 1 to "f" has incompatible type "List[TypedDict({'x'?: int, 'z'?: str})]"; expected "A"
[builtins fixtures/dict.pyi]

[case testNonTotalTypedDictCanBeEmpty]
# flags: --warn-unreachable
from mypy_extensions import TypedDict

class A(TypedDict):
    ...

class B(TypedDict, total=False):
    x: int

a: A = {}
b: B = {}

if not a:
    reveal_type(a) # N: Revealed type is 'TypedDict('__main__.A', {})'

if not b:
    reveal_type(b) # N: Revealed type is 'TypedDict('__main__.B', {'x'?: builtins.int})'
[builtins fixtures/dict.pyi]

-- Create Type (Errors)

[case testCannotCreateTypedDictTypeWithTooFewArguments]
from mypy_extensions import TypedDict
Point = TypedDict('Point')  # E: Too few arguments for TypedDict()
[builtins fixtures/dict.pyi]

[case testCannotCreateTypedDictTypeWithTooManyArguments]
from mypy_extensions import TypedDict
Point = TypedDict('Point', {'x': int, 'y': int}, dict)  # E: Unexpected arguments to TypedDict()
[builtins fixtures/dict.pyi]

[case testCannotCreateTypedDictTypeWithInvalidName]
from mypy_extensions import TypedDict
Point = TypedDict(dict, {'x': int, 'y': int})  # E: TypedDict() expects a string literal as the first argument
[builtins fixtures/dict.pyi]

[case testCannotCreateTypedDictTypeWithInvalidItems]
from mypy_extensions import TypedDict
Point = TypedDict('Point', {'x'})  # E: TypedDict() expects a dictionary literal as the second argument
[builtins fixtures/dict.pyi]

[case testCannotCreateTypedDictTypeWithKwargs]
from mypy_extensions import TypedDict
d = {'x': int, 'y': int}
Point = TypedDict('Point', {**d})  # E: Invalid TypedDict() field name
[builtins fixtures/dict.pyi]

-- NOTE: The following code works at runtime but is not yet supported by mypy.
--       Keyword arguments may potentially be supported in the future.
[case testCannotCreateTypedDictTypeWithNonpositionalArgs]
from mypy_extensions import TypedDict
Point = TypedDict(typename='Point', fields={'x': int, 'y': int})  # E: Unexpected arguments to TypedDict()
[builtins fixtures/dict.pyi]

[case testCannotCreateTypedDictTypeWithInvalidItemName]
from mypy_extensions import TypedDict
Point = TypedDict('Point', {int: int, int: int})  # E: Invalid TypedDict() field name
[builtins fixtures/dict.pyi]

[case testCannotCreateTypedDictTypeWithInvalidItemType]
from mypy_extensions import TypedDict
Point = TypedDict('Point', {'x': 1, 'y': 1})  # E: Invalid type: try using Literal[1] instead?
[builtins fixtures/dict.pyi]

[case testCannotCreateTypedDictTypeWithInvalidName]
from mypy_extensions import TypedDict
X = TypedDict('Y', {'x': int})  # E: First argument 'Y' to TypedDict() does not match variable name 'X'
[builtins fixtures/dict.pyi]


-- Overloading

[case testTypedDictOverloading]
from typing import overload, Iterable
from mypy_extensions import TypedDict

A = TypedDict('A', {'x': int})

@overload
def f(x: Iterable[str]) -> str: ...
@overload
def f(x: int) -> int: ...
def f(x): pass

a: A
reveal_type(f(a))  # N: Revealed type is 'builtins.str'
reveal_type(f(1))  # N: Revealed type is 'builtins.int'
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictOverloading2]
from typing import overload, Iterable
from mypy_extensions import TypedDict

A = TypedDict('A', {'x': int})

@overload
def f(x: Iterable[int]) -> None: ...
@overload
def f(x: int) -> None: ...
def f(x): pass

a: A
f(a)
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]
[out]
main:13: error: Argument 1 to "f" has incompatible type "A"; expected "Iterable[int]"
main:13: note: Following member(s) of "A" have conflicts:
main:13: note:     Expected:
main:13: note:         def __iter__(self) -> Iterator[int]
main:13: note:     Got:
main:13: note:         def __iter__(self) -> Iterator[str]

[case testTypedDictOverloading3]
from typing import overload
from mypy_extensions import TypedDict

A = TypedDict('A', {'x': int})

@overload
def f(x: str) -> None: ...
@overload
def f(x: int) -> None: ...
def f(x): pass

a: A
f(a)  # E: No overload variant of "f" matches argument type "A" \
      # N: Possible overload variants: \
      # N:     def f(x: str) -> None \
      # N:     def f(x: int) -> None
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictOverloading4]
from typing import overload
from mypy_extensions import TypedDict

A = TypedDict('A', {'x': int})
B = TypedDict('B', {'x': str})

@overload
def f(x: A) -> int: ...
@overload
def f(x: int) -> str: ...
def f(x): pass

a: A
b: B
reveal_type(f(a)) # N: Revealed type is 'builtins.int'
reveal_type(f(1)) # N: Revealed type is 'builtins.str'
f(b) # E: Argument 1 to "f" has incompatible type "B"; expected "A"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictOverloading5]
from typing import overload
from mypy_extensions import TypedDict

A = TypedDict('A', {'x': int})
B = TypedDict('B', {'y': str})
C = TypedDict('C', {'y': int})

@overload
def f(x: A) -> None: ...
@overload
def f(x: B) -> None: ...
def f(x): pass

a: A
b: B
c: C
f(a)
f(b)
f(c) # E: Argument 1 to "f" has incompatible type "C"; expected "A"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictOverloading6]
from typing import overload
from mypy_extensions import TypedDict

A = TypedDict('A', {'x': int})
B = TypedDict('B', {'y': str})

@overload
def f(x: A) -> int: ...
@overload
def f(x: B) -> str: ...
def f(x): pass

a: A
b: B
reveal_type(f(a)) # N: Revealed type is 'builtins.int'
reveal_type(f(b)) # N: Revealed type is 'builtins.str'
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]


-- Special cases

[case testForwardReferenceInTypedDict]
from typing import Mapping
from mypy_extensions import TypedDict
X = TypedDict('X', {'b': 'B', 'c': 'C'})
class B: pass
class C(B): pass
x: X
reveal_type(x) # N: Revealed type is 'TypedDict('__main__.X', {'b': __main__.B, 'c': __main__.C})'
m1: Mapping[str, object] = x
m2: Mapping[str, B] = x # E: Incompatible types in assignment (expression has type "X", variable has type "Mapping[str, B]")
[builtins fixtures/dict.pyi]

[case testForwardReferenceInClassTypedDict]
from typing import Mapping
from mypy_extensions import TypedDict
class X(TypedDict):
    b: 'B'
    c: 'C'
class B: pass
class C(B): pass
x: X
reveal_type(x) # N: Revealed type is 'TypedDict('__main__.X', {'b': __main__.B, 'c': __main__.C})'
m1: Mapping[str, object] = x
m2: Mapping[str, B] = x # E: Incompatible types in assignment (expression has type "X", variable has type "Mapping[str, B]")
[builtins fixtures/dict.pyi]

[case testForwardReferenceToTypedDictInTypedDict]
from typing import Mapping
from mypy_extensions import TypedDict
X = TypedDict('X', {'a': 'A'})
A = TypedDict('A', {'b': int})
x: X
reveal_type(x) # N: Revealed type is 'TypedDict('__main__.X', {'a': TypedDict('__main__.A', {'b': builtins.int})})'
reveal_type(x['a']['b']) # N: Revealed type is 'builtins.int'
[builtins fixtures/dict.pyi]

[case testSelfRecursiveTypedDictInheriting]

from mypy_extensions import TypedDict

class MovieBase(TypedDict):
    name: str
    year: int

class Movie(MovieBase):
    director: 'Movie' # E: Cannot resolve name "Movie" (possible cyclic definition)

m: Movie
reveal_type(m['director']['name']) # N: Revealed type is 'Any'
[builtins fixtures/dict.pyi]
[out]

[case testSubclassOfRecursiveTypedDict]

from typing import List
from mypy_extensions import TypedDict

class Command(TypedDict):
    subcommands: List['Command']  # E: Cannot resolve name "Command" (possible cyclic definition)

class HelpCommand(Command):
    pass

hc = HelpCommand(subcommands=[])
reveal_type(hc)  # N: Revealed type is 'TypedDict('__main__.HelpCommand', {'subcommands': builtins.list[Any]})'
[builtins fixtures/list.pyi]
[out]

[case testTypedDictForwardAsUpperBound]
from typing import TypeVar, Generic
from mypy_extensions import TypedDict
T = TypeVar('T', bound='M')
class G(Generic[T]):
    x: T

yb: G[int] # E: Type argument "builtins.int" of "G" must be a subtype of "TypedDict('__main__.M', {'x': builtins.int})"
yg: G[M]
z: int = G[M]().x['x']

class M(TypedDict):
    x: int
[builtins fixtures/dict.pyi]
[out]

[case testTypedDictWithImportCycleForward]
import a
[file a.py]
from mypy_extensions import TypedDict
from b import f

N = TypedDict('N', {'a': str})
[file b.py]
import a

def f(x: a.N) -> None:
    reveal_type(x)
    reveal_type(x['a'])
[builtins fixtures/dict.pyi]
[out]
tmp/b.py:4: note: Revealed type is 'TypedDict('a.N', {'a': builtins.str})'
tmp/b.py:5: note: Revealed type is 'builtins.str'

[case testTypedDictImportCycle]

import b
[file a.py]
class C:
    pass

from b import tp
x: tp
reveal_type(x['x'])  # N: Revealed type is 'builtins.int'

reveal_type(tp)  # N: Revealed type is 'def () -> b.tp'
tp(x='no')  # E: Incompatible types (expression has type "str", TypedDict item "x" has type "int")

[file b.py]
from a import C
from mypy_extensions import TypedDict

tp = TypedDict('tp', {'x': int})
[builtins fixtures/dict.pyi]
[out]

[case testTypedDictAsStarStarArg]
from mypy_extensions import TypedDict

A = TypedDict('A', {'x': int, 'y': str})
class B: pass

def f1(x: int, y: str) -> None: ...
def f2(x: int, y: int) -> None: ...
def f3(x: B, y: str) -> None: ...
def f4(x: int) -> None: pass
def f5(x: int, y: str, z: int) -> None: pass
def f6(x: int, z: str) -> None: pass

a: A
f1(**a)
f2(**a) # E: Argument "y" to "f2" has incompatible type "str"; expected "int"
f3(**a) # E: Argument "x" to "f3" has incompatible type "int"; expected "B"
f4(**a) # E: Extra argument "y" from **args for "f4"
f5(**a) # E: Too few arguments for "f5"
f6(**a) # E: Extra argument "y" from **args for "f6"
f1(1, **a) # E: "f1" gets multiple values for keyword argument "x"
[builtins fixtures/tuple.pyi]

[case testTypedDictAsStarStarArgConstraints]
from typing import TypeVar, Union
from mypy_extensions import TypedDict

T = TypeVar('T')
S = TypeVar('S')
def f1(x: T, y: S) -> Union[T, S]: ...

A = TypedDict('A', {'y': int, 'x': str})
a: A
reveal_type(f1(**a)) # N: Revealed type is 'Union[builtins.str*, builtins.int*]'
[builtins fixtures/tuple.pyi]

[case testTypedDictAsStarStarArgCalleeKwargs]
from mypy_extensions import TypedDict

A = TypedDict('A', {'x': int, 'y': str})
B = TypedDict('B', {'x': str, 'y': str})

def f(**kwargs: str) -> None: ...
def g(x: int, **kwargs: str) -> None: ...

a: A
b: B
f(**a) # E: Argument 1 to "f" has incompatible type "**A"; expected "str"
f(**b)
g(**a)
g(**b) # E: Argument "x" to "g" has incompatible type "str"; expected "int"
g(1, **a) # E: "g" gets multiple values for keyword argument "x"
g(1, **b) # E: "g" gets multiple values for keyword argument "x" \
          # E: Argument "x" to "g" has incompatible type "str"; expected "int"
[builtins fixtures/dict.pyi]

[case testTypedDictAsStarStarTwice]
from mypy_extensions import TypedDict

A = TypedDict('A', {'x': int, 'y': str})
B = TypedDict('B', {'z': bytes})
C = TypedDict('C', {'x': str, 'z': bytes})

def f1(x: int, y: str, z: bytes) -> None: ...
def f2(x: int, y: float, z: bytes) -> None: ...
def f3(x: int, y: str, z: float) -> None: ...

a: A
b: B
c: C
f1(**a, **b)
f1(**b, **a)
f2(**a, **b) # E: Argument "y" to "f2" has incompatible type "str"; expected "float"
f3(**a, **b) # E: Argument "z" to "f3" has incompatible type "bytes"; expected "float"
f3(**b, **a) # E: Argument "z" to "f3" has incompatible type "bytes"; expected "float"
f1(**a, **c) # E: "f1" gets multiple values for keyword argument "x" \
             # E: Argument "x" to "f1" has incompatible type "str"; expected "int"
f1(**c, **a) # E: "f1" gets multiple values for keyword argument "x" \
             # E: Argument "x" to "f1" has incompatible type "str"; expected "int"
[builtins fixtures/tuple.pyi]

[case testTypedDictNonMappingMethods]
from typing import List
from mypy_extensions import TypedDict

A = TypedDict('A', {'x': int, 'y': List[int]})
a: A

reveal_type(a.copy()) # N: Revealed type is 'TypedDict('__main__.A', {'x': builtins.int, 'y': builtins.list[builtins.int]})'
a.has_key('x') # E: "A" has no attribute "has_key"
# TODO: Better error message
a.clear() # E: "A" has no attribute "clear"

a.setdefault('invalid', 1) # E: TypedDict "A" has no key 'invalid'
reveal_type(a.setdefault('x', 1)) # N: Revealed type is 'builtins.int'
reveal_type(a.setdefault('y', [])) # N: Revealed type is 'builtins.list[builtins.int]'
a.setdefault('y', '') # E: Argument 2 to "setdefault" of "TypedDict" has incompatible type "str"; expected "List[int]"
x = ''
a.setdefault(x, 1) # E: Expected TypedDict key to be string literal
alias = a.setdefault
alias(x, 1) # E: Argument 1 has incompatible type "str"; expected "NoReturn"

a.update({})
a.update({'x': 1})
a.update({'x': ''}) # E: Incompatible types (expression has type "str", TypedDict item "x" has type "int")
a.update({'x': 1, 'y': []})
a.update({'x': 1, 'y': [1]})
a.update({'z': 1}) # E: Unexpected TypedDict key 'z'
a.update({'z': 1, 'zz': 1}) # E: Unexpected TypedDict keys ('z', 'zz')
a.update({'z': 1, 'x': 1}) # E: Expected TypedDict key 'x' but found keys ('z', 'x')
d = {'x': 1}
a.update(d) # E: Argument 1 to "update" of "TypedDict" has incompatible type "Dict[str, int]"; expected "TypedDict({'x'?: int, 'y'?: List[int]})"
[builtins fixtures/dict.pyi]

[case testTypedDictNonMappingMethods_python2]
from mypy_extensions import TypedDict
A = TypedDict('A', {'x': int})
a = A(x=1)
reveal_type(a.copy()) # N: Revealed type is 'TypedDict('__main__.A', {'x': builtins.int})'
reveal_type(a.has_key('y')) # N: Revealed type is 'builtins.bool'
a.clear() # E: "A" has no attribute "clear"
[builtins_py2 fixtures/dict.pyi]

[case testTypedDictPopMethod]
from typing import List
from mypy_extensions import TypedDict

A = TypedDict('A', {'x': int, 'y': List[int]}, total=False)
B = TypedDict('B', {'x': int})
a: A
b: B

reveal_type(a.pop('x')) # N: Revealed type is 'builtins.int'
reveal_type(a.pop('y', [])) # N: Revealed type is 'builtins.list[builtins.int]'
reveal_type(a.pop('x', '')) # N: Revealed type is 'Union[builtins.int, Literal['']?]'
reveal_type(a.pop('x', (1, 2))) # N: Revealed type is 'Union[builtins.int, Tuple[Literal[1]?, Literal[2]?]]'
a.pop('invalid', '') # E: TypedDict "A" has no key 'invalid'
b.pop('x') # E: Key 'x' of TypedDict "B" cannot be deleted
x = ''
b.pop(x) # E: Expected TypedDict key to be string literal
pop = b.pop
pop('x') # E: Argument 1 has incompatible type "str"; expected "NoReturn"
pop('invalid') # E: Argument 1 has incompatible type "str"; expected "NoReturn"
[builtins fixtures/dict.pyi]

[case testTypedDictDel]
from typing import List
from mypy_extensions import TypedDict

A = TypedDict('A', {'x': int, 'y': List[int]}, total=False)
B = TypedDict('B', {'x': int})
a: A
b: B

del a['x']
del a['invalid'] # E: TypedDict "A" has no key 'invalid'
del b['x'] # E: Key 'x' of TypedDict "B" cannot be deleted
s = ''
del a[s] # E: Expected TypedDict key to be string literal
del b[s] # E: Expected TypedDict key to be string literal
alias = b.__delitem__
alias('x') # E: Argument 1 has incompatible type "str"; expected "NoReturn"
alias(s) # E: Argument 1 has incompatible type "str"; expected "NoReturn"
[builtins fixtures/dict.pyi]

[case testPluginUnionsOfTypedDicts]
from typing import Union
from mypy_extensions import TypedDict

class TDA(TypedDict):
    a: int
    b: str

class TDB(TypedDict):
    a: int
    b: int
    c: int

td: Union[TDA, TDB]

reveal_type(td.get('a'))  # N: Revealed type is 'builtins.int'
reveal_type(td.get('b'))  # N: Revealed type is 'Union[builtins.str, builtins.int]'
reveal_type(td.get('c'))  # E: TypedDict "TDA" has no key 'c' \
                          # N: Revealed type is 'Union[Any, builtins.int]'

reveal_type(td['a'])  # N: Revealed type is 'builtins.int'
reveal_type(td['b'])  # N: Revealed type is 'Union[builtins.str, builtins.int]'
reveal_type(td['c'])  # N: Revealed type is 'Union[Any, builtins.int]' \
                      # E: TypedDict "TDA" has no key 'c'
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testPluginUnionsOfTypedDictsNonTotal]
from typing import Union
from mypy_extensions import TypedDict

class TDA(TypedDict, total=False):
    a: int
    b: str

class TDB(TypedDict, total=False):
    a: int
    b: int
    c: int

td: Union[TDA, TDB]

reveal_type(td.pop('a'))  # N: Revealed type is 'builtins.int'
reveal_type(td.pop('b'))  # N: Revealed type is 'Union[builtins.str, builtins.int]'
reveal_type(td.pop('c'))  # E: TypedDict "TDA" has no key 'c' \
                          # N: Revealed type is 'Union[Any, builtins.int]'
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testCanCreateTypedDictWithTypingExtensions]
# flags: --python-version 3.6
from typing_extensions import TypedDict

class Point(TypedDict):
    x: int
    y: int

p = Point(x=42, y=1337)
reveal_type(p)  # N: Revealed type is 'TypedDict('__main__.Point', {'x': builtins.int, 'y': builtins.int})'
[builtins fixtures/dict.pyi]

[case testCanCreateTypedDictWithTypingProper]
# flags: --python-version 3.8
from typing import TypedDict

class Point(TypedDict):
    x: int
    y: int

p = Point(x=42, y=1337)
reveal_type(p)  # N: Revealed type is 'TypedDict('__main__.Point', {'x': builtins.int, 'y': builtins.int})'
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictOptionalUpdate]
from typing import Union
from mypy_extensions import TypedDict

class A(TypedDict):
    x: int

d: Union[A, None]
d.update({'x': 1})
[builtins fixtures/dict.pyi]

[case testTypedDictOverlapWithDict]
# mypy: strict-equality
from typing import TypedDict, Dict

class Config(TypedDict):
    a: str
    b: str

x: Dict[str, str]
y: Config

x == y
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictOverlapWithDictNonOverlapping]
# mypy: strict-equality
from typing import TypedDict, Dict

class Config(TypedDict):
    a: str
    b: int

x: Dict[str, str]
y: Config

x == y  # E: Non-overlapping equality check (left operand type: "Dict[str, str]", right operand type: "Config")
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictOverlapWithDictNonTotal]
# mypy: strict-equality
from typing import TypedDict, Dict

class Config(TypedDict, total=False):
    a: str
    b: int

x: Dict[str, str]
y: Config

x == y
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictOverlapWithDictNonTotalNonOverlapping]
# mypy: strict-equality
from typing import TypedDict, Dict

class Config(TypedDict, total=False):
    a: int
    b: int

x: Dict[str, str]
y: Config

x == y  # E: Non-overlapping equality check (left operand type: "Dict[str, str]", right operand type: "Config")
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictOverlapWithDictEmpty]
# mypy: strict-equality
from typing import TypedDict

class Config(TypedDict):
    a: str
    b: str

x: Config
x == {}  # E: Non-overlapping equality check (left operand type: "Config", right operand type: "Dict[<nothing>, <nothing>]")
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictOverlapWithDictNonTotalEmpty]
# mypy: strict-equality
from typing import TypedDict

class Config(TypedDict, total=False):
    a: str
    b: str

x: Config
x == {}
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictOverlapWithDictNonStrKey]
# mypy: strict-equality
from typing import TypedDict, Dict, Union

class Config(TypedDict):
    a: str
    b: str

x: Config
y: Dict[Union[str, int], str]
x == y
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictOverlapWithDictOverload]
from typing import overload, TypedDict, Dict

class Map(TypedDict):
    x: int
    y: str

@overload
def func(x: Map) -> int: ...
@overload
def func(x: Dict[str, str]) -> str: ...
def func(x):
    pass
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictOverlapWithDictOverloadBad]
from typing import overload, TypedDict, Dict

class Map(TypedDict, total=False):
    x: int
    y: str

@overload
def func(x: Map) -> int: ...  # E: Overloaded function signatures 1 and 2 overlap with incompatible return types
@overload
def func(x: Dict[str, str]) -> str: ...
def func(x):
    pass
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictOverlapWithDictOverloadMappingBad]
from typing import overload, TypedDict, Mapping

class Map(TypedDict, total=False):
    x: int
    y: str

@overload
def func(x: Map) -> int: ...  # E: Overloaded function signatures 1 and 2 overlap with incompatible return types
@overload
def func(x: Mapping[str, str]) -> str: ...
def func(x):
    pass
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictOverlapWithDictOverloadNonStrKey]
from typing import overload, TypedDict, Dict

class Map(TypedDict):
    x: str
    y: str

@overload
def func(x: Map) -> int: ...
@overload
def func(x: Dict[int, str]) -> str: ...
def func(x):
    pass
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictIsInstance]
from typing import TypedDict, Union

class User(TypedDict):
    id: int
    name: str

u: Union[str, User]
u2: User

if isinstance(u, dict):
    reveal_type(u)  # N: Revealed type is 'TypedDict('__main__.User', {'id': builtins.int, 'name': builtins.str})'
else:
    reveal_type(u)  # N: Revealed type is 'builtins.str'

assert isinstance(u2, dict)
reveal_type(u2)  # N: Revealed type is 'TypedDict('__main__.User', {'id': builtins.int, 'name': builtins.str})'
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictIsInstanceABCs]
from typing import TypedDict, Union, Mapping, Iterable

class User(TypedDict):
    id: int
    name: str

u: Union[int, User]
u2: User

if isinstance(u, Iterable):
    reveal_type(u)  # N: Revealed type is 'TypedDict('__main__.User', {'id': builtins.int, 'name': builtins.str})'
else:
    reveal_type(u)  # N: Revealed type is 'builtins.int'

assert isinstance(u2, Mapping)
reveal_type(u2)  # N: Revealed type is 'TypedDict('__main__.User', {'id': builtins.int, 'name': builtins.str})'
[builtins fixtures/dict.pyi]
[typing fixtures/typing-full.pyi]

[case testTypedDictLiteralTypeKeyInCreation]
from typing import TypedDict, Final, Literal

class Value(TypedDict):
    num: int

num: Final = 'num'
v: Value = {num: 5}
v = {num: ''}  # E: Incompatible types (expression has type "str", TypedDict item "num" has type "int")

bad: Final = 2
v = {bad: 3}  # E: Expected TypedDict key to be string literal
union: Literal['num', 'foo']
v = {union: 2} # E: Expected TypedDict key to be string literal
num2: Literal['num']
v = {num2: 2}
bad2: Literal['bad']
v = {bad2: 2}  # E: Extra key 'bad' for TypedDict "Value"

[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testCannotUseFinalDecoratorWithTypedDict]
from typing import TypedDict
from typing_extensions import final

@final  # E: @final cannot be used with TypedDict
class DummyTypedDict(TypedDict):
    int_val: int
    float_val: float
    str_val: str

[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictDoubleForwardClass]
from mypy_extensions import TypedDict
from typing import Any, List

class Foo(TypedDict):
    bar: Bar
    baz: Bar

Bar = List[Any]

foo: Foo
reveal_type(foo['bar'])  # N: Revealed type is 'builtins.list[Any]'
reveal_type(foo['baz'])  # N: Revealed type is 'builtins.list[Any]'
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictDoubleForwardFunc]
from mypy_extensions import TypedDict
from typing import Any, List

Foo = TypedDict('Foo', {'bar': Bar, 'baz': Bar})

Bar = List[Any]

foo: Foo
reveal_type(foo['bar'])   # N: Revealed type is 'builtins.list[Any]'
reveal_type(foo['baz'])  # N: Revealed type is 'builtins.list[Any]'
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictDoubleForwardMixed]
from mypy_extensions import TypedDict
from typing import Any, List

Bar = List[Any]

class Foo(TypedDict):
    foo: Toto
    bar: Bar
    baz: Bar

Toto = int

foo: Foo
reveal_type(foo['foo'])  # N: Revealed type is 'builtins.int'
reveal_type(foo['bar'])  # N: Revealed type is 'builtins.list[Any]'
reveal_type(foo['baz'])  # N: Revealed type is 'builtins.list[Any]'
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testAssignTypedDictAsAttribute]
from typing import TypedDict

class A:
    def __init__(self) -> None:
        self.b = TypedDict('b', {'x': int, 'y': str})  # E: TypedDict type as attribute is not supported

reveal_type(A().b)  # N: Revealed type is 'Any'
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictAsUpperBoundAndIndexedAssign]
from typing import TypeVar, Generic, TypedDict


class BaseDict(TypedDict, total=False):
    foo: int


_DICT_T = TypeVar('_DICT_T', bound=BaseDict)


class SomeGeneric(Generic[_DICT_T]):
    def __init__(self, data: _DICT_T) -> None:
        self._data: _DICT_T = data

    def set_state(self) -> None:
        self._data['foo'] = 1
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictCreatedWithEmptyDict]
from typing import TypedDict

class TD(TypedDict, total=False):
    foo: int
    bar: int

d: TD = dict()
d2: TD = dict(foo=1)
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictBytesKey]
from typing import TypedDict

class TD(TypedDict):
    foo: int

d: TD = {b'foo': 2} # E: Expected TypedDict key to be string literal
d[b'foo'] = 3 # E: TypedDict key must be a string literal; expected one of ('foo') \
    # E: Argument 1 has incompatible type "bytes"; expected "str"
d[b'foo'] # E: TypedDict key must be a string literal; expected one of ('foo')
d[3] # E: TypedDict key must be a string literal; expected one of ('foo')
d[True] # E: TypedDict key must be a string literal; expected one of ('foo')
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]
